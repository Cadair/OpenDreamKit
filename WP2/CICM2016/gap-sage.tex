\section{Distributed Collaboration with GAP/Sage}\label{sec:gapsage}
\begin{newpart}{MK@MK: completely rewrite from a high-level perspective the material that
    is now in \texttt{deleted-scenes.tex} and should be extended to a technical paper}
Another aspect of interoperability in a mathematical VRE is the possibility of distributed
multisystem computations, where e.g. a given system may decide to delegate
certain subcomputations or reasoning tasks to other systems.

There are already a variety of peer-to-peer interfaces (see Figure~\ref{fig:interop})
based on the ``handle paradigm'' between systems in the \ODK project;
for example \Sage includes interfaces for \GAP, \Singular, or \Pari.

In the ``handle paradigm'', when a system $A$ delegates a calculation to a system $B$, the
result $r$ of the calculation is not converted to a native $A$ object; instead $B$ just
returns a handle (or reference) to the object $r$. Later $A$ can run further calculations
with $r$ by passing it as argument to $B$ functions or methods. The advantages of this
approach include that we can avoid the overhead of back and forth conversions between $A$
and $B$ and that we can manipulate objects of $B$ from $A$ even if they have no native
representation in $A$.

Given a mapping of corresponding methods in the systems, we can use the adaptor pattern to
implement this. For example, calling the method \texttt{h.cardinality()} on a \Sage handle
\texttt{h} to a \GAP object \texttt{G}, triggers in \GAP a call to \texttt{Size(G)} if
\texttt{cardinality} and \texttt{Size} are marked as corresponding. But this dispatch
depends on an alignment of the type systems in \Sage and \GAP. For example, if \texttt{h}
is a handle to a set \texttt{S}, \Sage only knows that \texttt{h.cardinality()} can be
computed by \texttt{Size(S)} in \GAP if \texttt{S} is a group; in fact if \texttt{h} has
been constructed through the \texttt{PermutationGroup} or \texttt{MatrixGroup}
constructors. Whereas we would want this method to be available as soon as \texttt{S} is a
set.

To get around this problem we have worked on a more semantic
integration, where adaptor methods are made aware of the type
hierarchies of the respective other system, see
Listing~\ref{lst:adaptor} below.
\begin{lstlisting}[language=Python,label=lst:adaptor,
  caption=A Semantic Adaptor Method in \Sage]
class Sets: # Everything generic about sets in Sage
    class GAP: # The adapter methods relevant to Sets in the Sage-Gap interface
         class ParentMethods: # Adapter methods for sets
             def cardinality(self): # The adapter for the cardinality method
                 return self.gap().Size().sage()
         class ElementMethods: # Adapter methods for set elements
             ...
         class MorphismMethods: # Adapter methods for set morphisms
             ...
\end{lstlisting}

This peer-to-peer approach however does not scale up to a dozen of
systems. This is where the MitM paradigm comes to the rescue. With it,
the task is reduced to building interface theories and interviews into
the core MitM ontology, in such a way that the adaptor pattern can be
made generic in terms of the MitM ontology structure, without relying
on the concrete structure of the respective type systems. Then the
adapter methods for each peer-to-peer interface can be automatically
generated.

In our example, the correspondence between \texttt{cardinality} and
\texttt{Size} still holds if the MitM interviews link the
\texttt{cardinality} function in the \Sage interface theory on sets
with the \texttt{Size} function in the corresponding interface theory
for \GAP.

We will now show first results of our experiments with interface
theories and interviews, including several applications beyond the
generation of interface theories that support distributed computation
for \Sage and \GAP.
\end{newpart}

\subsection{Semantics in the \Sage Category System}

The \Sage library includes 40k functions and allows for manipulating
thousands of different kinds of objects. As usual in such large
systems, itâ€™s critical for taming code bloat to
\begin{inparaenum}[\em i\rm)]
\item identify the core concepts describing common behavior among the objects;
\item exploit this to implement generic operations that apply on all object having a given
  behavior, with appropriate specializations when performance calls for it.
\item design or choose a process for selecting the best implementation available when
  calling an operation on one or several objects.
\end{inparaenum}

Following mathematical tradition and the precedent of the \Axiom,
\Fricas, or \MuPAD systems, \Sage has developed a
category-theory-inspired ``category system'', and found a way to
implement it on top of the underlying \Python object
system~\cite{Sage.Categories}.
%
This category system models taxonomic knowledge from mathematics
explicitly and uses it to support genericity, control the method
selection process, structure the code and documentation, enforce
consistency, and provide generic tests.

\ednote{NT: switch this example to (magmas, *)?}
\ednote{NT: how is ``cardinality'' called in MMT?}
\ednote{NT: it would be nice to include here the MMT formalization of
  Size/cardinality}
\begin{wrapfigure}r{7cm}\vspace*{-2.5em}
\begin{lstlisting}[language=Python]
@semantic(mmt="sets")
class Sets:
    class ParentMethods:
         @semantic(mmt="?????", gap="Size")
         @abstractmethod
         def cardinality(self):
             r"""
             Return the cardinality of ``self``.
             """
\end{lstlisting}
\vspace*{-.5em}
\caption{An anotated Category in \Sage}\label{fig:anncat}\vspace*{-1.5em}
\end{wrapfigure}
To generate interface theories from the \Sage category system, we are experimenting with a
system of annotations in the \Sage source files. Consider for instance the situtation in
Figure~\ref{fig:anncat} where we have annotated the \texttt{Sets()} category in \Sage
with \texttt{@semantic} lines that state correspondences to other interface theories. From
these the \Sage-to-MMT exporter can generate the respective interface theories and views.

Several variants of the annotations are experimented with to allow for adding annotations on existing
categories without touching their source file, and also for specifying directly the corresponding
method names in other systems when this has not yet been formalized elsewhere. Similarly,
one can provide directly the signature information in case that is not yet modelled in
MMT.

\subsection{Exporting the \GAP Type System}
\ednote{summarize the \GAP stuff here, also add the picture}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
